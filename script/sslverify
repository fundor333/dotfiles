#!/usr/bin/env python

import datetime
import fileinput
import logging
import os
import socket
import ssl
import time

import emoji
import sys

logger = logging.getLogger("SSLVerify")


class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def ssl_expiry_datetime(hostname: str) -> datetime.datetime:
    ssl_date_fmt = r"%b %d %H:%M:%S %Y %Z"

    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(
        socket.AF_INET), server_hostname=hostname,)
    # 3 second timeout because Lambda has runtime limitations
    conn.settimeout(3.0)

    logger.debug("Connect to {}".format(hostname))
    conn.connect((hostname, 443))
    ssl_info = conn.getpeercert()
    # parse the string from the certificate into a Python datetime object
    return datetime.datetime.strptime(ssl_info["notAfter"], ssl_date_fmt)


def ssl_valid_time_remaining(hostname: str) -> datetime.timedelta:
    """Get the number of days left in a cert's lifetime."""
    expires = ssl_expiry_datetime(hostname)
    logger.debug("SSL cert for {} expires at {}".format(
        hostname, expires.isoformat()))
    return expires - datetime.datetime.utcnow()


def test_host(hostname: str, buffer_days: int = 30) -> str:
    """Return test message for hostname cert expiration."""
    output_strng = None
    try:
        will_expire_in = ssl_valid_time_remaining(hostname)
    except socket.gaierror as e:
        output_strng = f"{bcolors.FAIL}{emoji.emojize(':cross_mark: ', use_aliases=True)} {hostname} found nothing. Maybe wrong hostname{bcolors.ENDC}"
    except ssl.CertificateError as e:
        if "Hostname mismatch" in str(e):
            output_strng = f"{bcolors.FAIL}{emoji.emojize(':cross_mark: ', use_aliases=True)} Host mismatch, certificate is not valid for {hostname}"
    except ssl.SSLError as e:
        output_strng = f"{bcolors.FAIL}{emoji.emojize(':cross_mark: ', use_aliases=True)} {hostname} SSL error {e}"
    except socket.timeout as e:
        output_strng = f"{bcolors.FAIL}{emoji.emojize(':cross_mark: ', use_aliases=True)} {hostname} could not connect"
    else:
        if will_expire_in < datetime.timedelta(days=0):
            output_strng = f"{bcolors.FAIL}{emoji.emojize(':cross_mark: ', use_aliases=True)} {hostname} cert will expired"
        elif will_expire_in < datetime.timedelta(days=buffer_days):
            output_strng = f"{bcolors.WARNING}{emoji.emojize(':hourglass_not_done: ', use_aliases=True)} {hostname} cert will expire in { will_expire_in}"
        else:
            output_strng = f"{bcolors.OKBLUE}{ emoji.emojize(':thumbsup: ', use_aliases=True)} {hostname} cert is fine"
    logger.info(output_strng)
    return output_strng


if __name__ == "__main__":
    if len(sys.argv) > 1:
        for e in sys.argv[1:]:
            print(test_host(e))
    else:
        f = open(os.path.expanduser("~/.sslverify"), "r", encoding="utf-8")
        end_message = ""
        for host in f.readlines():
            host = host.strip()
            message = test_host(host)
            print(message)
